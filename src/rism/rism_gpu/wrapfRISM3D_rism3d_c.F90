! wrapfRISM3D_rism3d_c.F90
! This file is generated by Shroud 0.13.0. Do not edit.
!>
!! \file wrapfRISM3D_rism3d_c.F90
!! \brief Shroud generated wrapper for rism3d_c namespace
!<
! splicer begin namespace.rism3d_c.file_top
! splicer end namespace.rism3d_c.file_top
module rism3d_rism3d_c_mod
    use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT, C_LONG, C_NULL_PTR, C_PTR, C_SIZE_T
    ! splicer begin namespace.rism3d_c.module_use
    use rism3d_solute_c
    use rism3d_solvent_c
    ! splicer end namespace.rism3d_c.module_use
    implicit none

    ! splicer begin namespace.rism3d_c.module_top
    ! splicer end namespace.rism3d_c.module_top

    ! helper capsule_data_helper
    type, bind(C) :: RIS_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type RIS_SHROUD_capsule_data

    ! helper array_context
    type, bind(C) :: RIS_SHROUD_array
        ! address of C++ memory
        type(RIS_SHROUD_capsule_data) :: cxx
        ! address of data in cxx
        type(C_PTR) :: base_addr = C_NULL_PTR
        ! type of element
        integer(C_INT) :: type
        ! bytes-per-item or character len of data in cxx
        integer(C_SIZE_T) :: elem_len = 0_C_SIZE_T
        ! size of data in cxx
        integer(C_SIZE_T) :: size = 0_C_SIZE_T
        ! number of dimensions
        integer(C_INT) :: rank = -1
        integer(C_LONG) :: shape(7) = 0
    end type RIS_SHROUD_array

    ! helper type_defines
    ! Shroud type defines from helper type_defines
    integer, parameter, private :: &
        SH_TYPE_SIGNED_CHAR= 1, &
        SH_TYPE_SHORT      = 2, &
        SH_TYPE_INT        = 3, &
        SH_TYPE_LONG       = 4, &
        SH_TYPE_LONG_LONG  = 5, &
        SH_TYPE_SIZE_T     = 6, &
        SH_TYPE_UNSIGNED_SHORT      = SH_TYPE_SHORT + 100, &
        SH_TYPE_UNSIGNED_INT        = SH_TYPE_INT + 100, &
        SH_TYPE_UNSIGNED_LONG       = SH_TYPE_LONG + 100, &
        SH_TYPE_UNSIGNED_LONG_LONG  = SH_TYPE_LONG_LONG + 100, &
        SH_TYPE_INT8_T    =  7, &
        SH_TYPE_INT16_T   =  8, &
        SH_TYPE_INT32_T   =  9, &
        SH_TYPE_INT64_T   = 10, &
        SH_TYPE_UINT8_T  =  SH_TYPE_INT8_T + 100, &
        SH_TYPE_UINT16_T =  SH_TYPE_INT16_T + 100, &
        SH_TYPE_UINT32_T =  SH_TYPE_INT32_T + 100, &
        SH_TYPE_UINT64_T =  SH_TYPE_INT64_T + 100, &
        SH_TYPE_FLOAT       = 22, &
        SH_TYPE_DOUBLE      = 23, &
        SH_TYPE_LONG_DOUBLE = 24, &
        SH_TYPE_FLOAT_COMPLEX      = 25, &
        SH_TYPE_DOUBLE_COMPLEX     = 26, &
        SH_TYPE_LONG_DOUBLE_COMPLEX= 27, &
        SH_TYPE_BOOL      = 28, &
        SH_TYPE_CHAR      = 29, &
        SH_TYPE_CPTR      = 30, &
        SH_TYPE_STRUCT    = 31, &
        SH_TYPE_OTHER     = 32


    ! start derived-type solvent_cpp
    type, bind(C) :: solvent_cpp
        real(C_DOUBLE) :: temperature
        real(C_DOUBLE) :: dielconst
        real(C_DOUBLE) :: xappa
        real(C_DOUBLE) :: xikt
        real(C_DOUBLE) :: smear
        real(C_DOUBLE) :: xikt_dT
        integer(C_INT) :: numAtomTypes
        integer(C_INT) :: numMolecules
        integer(C_INT) :: numRDFpoints
        type(C_PTR) :: atomMultiplicity
        type(C_PTR) :: numAtoms
        type(C_PTR) :: atomName
        real(C_DOUBLE) :: gridSpacingR
        real(C_DOUBLE) :: gridSpacingK
        type(C_PTR) :: waveNumbers
        type(C_PTR) :: xvv
        type(C_PTR) :: xvv_dT
        type(C_PTR) :: charge
        type(C_PTR) :: charge_sp
        type(C_PTR) :: density
        type(C_PTR) :: density_sp
        type(C_PTR) :: ljSigma
        type(C_PTR) :: ljEpsilon
        type(C_PTR) :: coord
        type(C_PTR) :: background_correction
        type(C_PTR) :: delhv0
        type(C_PTR) :: delhv0_dT
        logical :: ionic
        real(C_DOUBLE) :: xvv_version
    end type solvent_cpp
    ! end derived-type solvent_cpp


    ! start derived-type solute_cpp
    type, bind(C) :: solute_cpp
        integer(C_INT) :: numAtoms
        type(C_PTR) :: mass
        type(C_PTR) :: charge
        type(C_PTR) :: origCharge
        type(C_PTR) :: position
        type(C_PTR) :: ljSigma
        type(C_PTR) :: ljEpsilon
        logical :: charged
        real(C_DOUBLE) :: totalCharge
        type(C_PTR) :: centerOfMass
        type(C_PTR) :: translation
    end type solute_cpp
    ! end derived-type solute_cpp


    ! start derived-type timer_cpp
    type, bind(C) :: timer_cpp
        type(C_PTR) :: name
        logical :: running
        logical :: startedParent
        logical :: displaced
        integer(C_INT) :: sublevels
        real(C_DOUBLE) :: total
        real(C_DOUBLE) :: timestamp
        type(C_PTR) :: parent
        type(C_PTR) :: child
    end type timer_cpp
    ! end derived-type timer_cpp

    type rism3d
        type(RIS_SHROUD_capsule_data) :: cxxmem
        ! splicer begin namespace.rism3d_c.class.rism3d.component_part
        ! splicer end namespace.rism3d_c.class.rism3d.component_part
    contains
        procedure :: delete => rism3d_delete
        procedure :: createelectrondensitymap => rism3d_createelectrondensitymap
        procedure :: get_spacing => rism3d_get_spacing
        procedure :: get_voxelvectorsr => rism3d_get_voxelvectorsr
        procedure :: get_unitcellangles => rism3d_get_unitcellangles
        procedure :: get_unitcellvectorsk => rism3d_get_unitcellvectorsk
        procedure :: get_unitcellvectorsr => rism3d_get_unitcellvectorsr
        procedure :: get_boxlength => rism3d_get_boxlength
        procedure :: get_totallocalpointsr => rism3d_get_totallocalpointsr
        procedure :: set_nsolution => rism3d_set_nsolution
        procedure :: get_nsolution => rism3d_get_nsolution
        procedure :: get_voxelvolume => rism3d_get_voxelvolume
        procedure :: get_localdimsr_0 => rism3d_get_localdimsr_0
        procedure :: get_localdimsr_1 => rism3d_get_localdimsr_1
        procedure :: get_globaldimsr_0 => rism3d_get_globaldimsr_0
        procedure :: get_globaldimsr_1 => rism3d_get_globaldimsr_1
        procedure :: get_atomname => rism3d_get_atomname
        procedure :: get_xikt_dt => rism3d_get_xikt_dt
        procedure :: get_temperature => rism3d_get_temperature
        procedure :: get_charge_0 => rism3d_get_charge_0
        procedure :: get_charge_1 => rism3d_get_charge_1
        procedure :: get_density_0 => rism3d_get_density_0
        procedure :: get_density_1 => rism3d_get_density_1
        procedure :: get_ionic => rism3d_get_ionic
        procedure :: get_centerofmass => rism3d_get_centerofmass
        procedure :: get_translation => rism3d_get_translation
        procedure :: get_charged => rism3d_get_charged
        procedure :: get_mass => rism3d_get_mass
        procedure :: get_guv_0 => rism3d_get_guv_0
        procedure :: get_guv_1 => rism3d_get_guv_1
        procedure :: get_huv_0 => rism3d_get_huv_0
        procedure :: get_huv_1 => rism3d_get_huv_1
        procedure :: get_cuv_0 => rism3d_get_cuv_0
        procedure :: get_cuv_1 => rism3d_get_cuv_1
        procedure :: get_guv_dt_0 => rism3d_get_guv_dt_0
        procedure :: get_guv_dt_1 => rism3d_get_guv_dt_1
        procedure :: get_electronmap => rism3d_get_electronmap
        procedure :: get_tcflongrangeasympr => rism3d_get_tcflongrangeasympr
        procedure :: get_dcflongrangeasympr_0 => rism3d_get_dcflongrangeasympr_0
        procedure :: get_dcflongrangeasympr_1 => rism3d_get_dcflongrangeasympr_1
        procedure :: get_uuv => rism3d_get_uuv
        procedure :: get_periodic => rism3d_get_periodic
        procedure :: get_failure => rism3d_get_failure
        procedure :: set_atomname => rism3d_set_atomname
        procedure :: setverbosity => rism3d_setverbosity
        procedure :: settimerparent => rism3d_settimerparent
        procedure :: setcoord => rism3d_setcoord
        procedure :: calculatesolution => rism3d_calculatesolution
        procedure :: force => rism3d_force
        procedure :: excesschemicalpotential_tot_0 => rism3d_excesschemicalpotential_tot_0
        procedure :: excesschemicalpotential_tot_1 => rism3d_excesschemicalpotential_tot_1
        procedure :: excesschemicalpotential_0 => rism3d_excesschemicalpotential_0
        procedure :: excesschemicalpotential_1 => rism3d_excesschemicalpotential_1
        procedure :: excesschemicalpotentialgf_0 => rism3d_excesschemicalpotentialgf_0
        procedure :: excesschemicalpotentialgf_1 => rism3d_excesschemicalpotentialgf_1
        procedure :: excesschemicalpotentialpcplus_0 => rism3d_excesschemicalpotentialpcplus_0
        procedure :: excesschemicalpotentialpcplus_1 => rism3d_excesschemicalpotentialpcplus_1
        procedure :: excesschemicalpotentialuc_0 => rism3d_excesschemicalpotentialuc_0
        procedure :: excesschemicalpotentialuc_1 => rism3d_excesschemicalpotentialuc_1
        procedure :: excesschemicalpotential_tot_map => rism3d_excesschemicalpotential_tot_map
        procedure :: excesschemicalpotentialgf_tot_map => rism3d_excesschemicalpotentialgf_tot_map
        procedure :: excesschemicalpotentialpcplus_tot_map => rism3d_excesschemicalpotentialpcplus_tot_map
        procedure :: excesschemicalpotentialuc_tot_map => rism3d_excesschemicalpotentialuc_tot_map
        procedure :: solventpotene_tot_map => rism3d_solventpotene_tot_map
        procedure :: solvationenergy_tot_map => rism3d_solvationenergy_tot_map
        procedure :: solvationenergygf_tot_map => rism3d_solvationenergygf_tot_map
        procedure :: solvationenergypcplus_tot_map => rism3d_solvationenergypcplus_tot_map
        procedure :: solvationenergyuc_tot_map => rism3d_solvationenergyuc_tot_map
        procedure :: excesschemicalpotential_site_map => rism3d_excesschemicalpotential_site_map
        procedure :: excesschemicalpotentialgf_site_map => rism3d_excesschemicalpotentialgf_site_map
        procedure :: solventpotene_site_map => rism3d_solventpotene_site_map
        procedure :: solvationenergy_site_map => rism3d_solvationenergy_site_map
        procedure :: solventpotene => rism3d_solventpotene
        procedure :: partialmolarvolume => rism3d_partialmolarvolume
        procedure :: excessparticles_0 => rism3d_excessparticles_0
        procedure :: excessparticles_1 => rism3d_excessparticles_1
        procedure :: kirkwoodbuff_0 => rism3d_kirkwoodbuff_0
        procedure :: kirkwoodbuff_1 => rism3d_kirkwoodbuff_1
        procedure :: dcfintegral => rism3d_dcfintegral
        procedure :: cancalc_dt => rism3d_cancalc_dt
        procedure :: calculatesolution_dt => rism3d_calculatesolution_dt
        procedure :: solvationenergy_0 => rism3d_solvationenergy_0
        procedure :: solvationenergy_1 => rism3d_solvationenergy_1
        procedure :: solvationenergygf_0 => rism3d_solvationenergygf_0
        procedure :: solvationenergygf_1 => rism3d_solvationenergygf_1
        procedure :: solvationenergygf_site_map => rism3d_solvationenergygf_site_map
        procedure :: excessparticles_dt_0 => rism3d_excessparticles_dt_0
        procedure :: excessparticles_dt_1 => rism3d_excessparticles_dt_1
        procedure :: kirkwoodbuff_dt_0 => rism3d_kirkwoodbuff_dt_0
        procedure :: kirkwoodbuff_dt_1 => rism3d_kirkwoodbuff_dt_1
        procedure :: dcfintegral_dt => rism3d_dcfintegral_dt
        procedure :: solvationenergypcplus_0 => rism3d_solvationenergypcplus_0
        procedure :: solvationenergypcplus_1 => rism3d_solvationenergypcplus_1
        procedure :: solvationenergyuc_0 => rism3d_solvationenergyuc_0
        procedure :: solvationenergyuc_1 => rism3d_solvationenergyuc_1
        procedure :: partialmolarvolume_dt => rism3d_partialmolarvolume_dt
        procedure :: unsetcharges => rism3d_unsetcharges
        procedure :: resetcharges => rism3d_resetcharges
        procedure :: map_site_to_site_flat => rism3d_map_site_to_site_flat
        procedure :: map_site_to_site_3_d => rism3d_map_site_to_site_3_d
        procedure :: selftest => rism3d_selftest
        procedure :: set_closurelist => rism3d_set_closurelist
        procedure :: print_tests => rism3d_print_tests
        procedure :: opendx_write_cpp => rism3d_opendx_write_cpp
        procedure :: mrc_map_write_cpp => rism3d_mrc_map_write_cpp
        procedure :: xyzv_write_cpp => rism3d_xyzv_write_cpp
        procedure :: get_instance => rism3d_get_instance
        procedure :: set_instance => rism3d_set_instance
        procedure :: associated => rism3d_associated
        generic :: excesschemicalpotential => excesschemicalpotential_0 &
            , excesschemicalpotential_1
        generic :: excesschemicalpotential_tot =>  &
            excesschemicalpotential_tot_0, excesschemicalpotential_tot_1
        generic :: excesschemicalpotentialgf =>  &
            excesschemicalpotentialgf_0, excesschemicalpotentialgf_1
        generic :: excesschemicalpotentialpcplus =>  &
            excesschemicalpotentialpcplus_0,  &
            excesschemicalpotentialpcplus_1
        generic :: excesschemicalpotentialuc =>  &
            excesschemicalpotentialuc_0, excesschemicalpotentialuc_1
        generic :: excessparticles => excessparticles_0,  &
            excessparticles_1
        generic :: excessparticles_dt => excessparticles_dt_0,  &
            excessparticles_dt_1
        generic :: get_charge => get_charge_0, get_charge_1
        generic :: get_cuv => get_cuv_0, get_cuv_1
        generic :: get_dcflongrangeasympr => get_dcflongrangeasympr_0,  &
            get_dcflongrangeasympr_1
        generic :: get_density => get_density_0, get_density_1
        generic :: get_globaldimsr => get_globaldimsr_0,  &
            get_globaldimsr_1
        generic :: get_guv => get_guv_0, get_guv_1
        generic :: get_guv_dt => get_guv_dt_0, get_guv_dt_1
        generic :: get_huv => get_huv_0, get_huv_1
        generic :: get_localdimsr => get_localdimsr_0, get_localdimsr_1
        generic :: kirkwoodbuff => kirkwoodbuff_0, kirkwoodbuff_1
        generic :: kirkwoodbuff_dt => kirkwoodbuff_dt_0,  &
            kirkwoodbuff_dt_1
        generic :: solvationenergy => solvationenergy_0,  &
            solvationenergy_1
        generic :: solvationenergygf => solvationenergygf_0,  &
            solvationenergygf_1
        generic :: solvationenergypcplus => solvationenergypcplus_0,  &
            solvationenergypcplus_1
        generic :: solvationenergyuc => solvationenergyuc_0,  &
            solvationenergyuc_1
        ! splicer begin namespace.rism3d_c.class.rism3d.type_bound_procedure_part

        ! splicer end namespace.rism3d_c.class.rism3d.type_bound_procedure_part
    end type rism3d

    interface operator (.eq.)
        module procedure rism3d_eq
    end interface

    interface operator (.ne.)
        module procedure rism3d_ne
    end interface

    interface

        function c_rism3d_new_0(solu_f, solv_f, centering, ncuvsteps, &
                closure, cut, mdiis_nvec, mdiis_del, mdiis_method, &
                mdiis_restart, treeDCF, treeTCF, treeCoulomb, &
                treeDCFMAC, treeTCFMAC, treeCoulombMAC, treeDCFOrder, &
                treeTCFOrder, treeCoulombOrder, treeDCFN0, treeTCFN0, &
                treeCoulombN0, asympKSpaceTolerance, ljTolerance, &
                chargeSmear, o_buffer, o_grdspc, o_mpicomm, o_periodic, &
                o_unitCellDimensions, o_biasPotential, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="RIS_rism3d_c_rism3d_new_0")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_DOUBLE, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data, solute_cpp, solvent_cpp
            implicit none
            type(solute_cpp), intent(INOUT) :: solu_f
            type(solvent_cpp), intent(INOUT) :: solv_f
            integer(C_INT), value, intent(IN) :: centering
            integer(C_INT), value, intent(IN) :: ncuvsteps
            type(C_PTR), intent(IN) :: closure(*)
            real(C_DOUBLE), value, intent(IN) :: cut
            integer(C_INT), value, intent(IN) :: mdiis_nvec
            real(C_DOUBLE), value, intent(IN) :: mdiis_del
            integer(C_INT), value, intent(IN) :: mdiis_method
            real(C_DOUBLE), value, intent(IN) :: mdiis_restart
            logical(C_BOOL), value, intent(IN) :: treeDCF
            logical(C_BOOL), value, intent(IN) :: treeTCF
            logical(C_BOOL), value, intent(IN) :: treeCoulomb
            real(C_DOUBLE), value, intent(IN) :: treeDCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeTCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeCoulombMAC
            integer(C_INT), value, intent(IN) :: treeDCFOrder
            integer(C_INT), value, intent(IN) :: treeTCFOrder
            integer(C_INT), value, intent(IN) :: treeCoulombOrder
            integer(C_INT), value, intent(IN) :: treeDCFN0
            integer(C_INT), value, intent(IN) :: treeTCFN0
            integer(C_INT), value, intent(IN) :: treeCoulombN0
            real(C_DOUBLE), value, intent(IN) :: asympKSpaceTolerance
            real(C_DOUBLE), value, intent(IN) :: ljTolerance
            real(C_DOUBLE), value, intent(IN) :: chargeSmear
            real(C_DOUBLE), value, intent(IN) :: o_buffer
            real(C_DOUBLE), intent(INOUT) :: o_grdspc(*)
            integer(C_INT), value, intent(IN) :: o_mpicomm
            character(kind=C_CHAR), intent(INOUT) :: o_periodic(*)
            real(C_DOUBLE), intent(INOUT) :: o_unitCellDimensions(*)
            real(C_DOUBLE), value, intent(IN) :: o_biasPotential
            type(RIS_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_rism3d_new_0

        function c_rism3d_new_0_bufferify(solu_f, solv_f, centering, &
                ncuvsteps, closure, SHT_closure_size, SHT_closure_len, &
                cut, mdiis_nvec, mdiis_del, mdiis_method, mdiis_restart, &
                treeDCF, treeTCF, treeCoulomb, treeDCFMAC, treeTCFMAC, &
                treeCoulombMAC, treeDCFOrder, treeTCFOrder, &
                treeCoulombOrder, treeDCFN0, treeTCFN0, treeCoulombN0, &
                asympKSpaceTolerance, ljTolerance, chargeSmear, &
                o_buffer, o_grdspc, o_mpicomm, o_periodic, &
                SHT_o_periodic_len, o_unitCellDimensions, &
                o_biasPotential, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="RIS_rism3d_c_rism3d_new_0_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_DOUBLE, C_INT, C_PTR, C_SIZE_T
            import :: RIS_SHROUD_capsule_data, solute_cpp, solvent_cpp
            implicit none
            type(solute_cpp), intent(INOUT) :: solu_f
            type(solvent_cpp), intent(INOUT) :: solv_f
            integer(C_INT), value, intent(IN) :: centering
            integer(C_INT), value, intent(IN) :: ncuvsteps
            character(kind=C_CHAR), intent(IN) :: closure(*)
            integer(C_SIZE_T), intent(IN), value :: SHT_closure_size
            integer(C_INT), intent(IN), value :: SHT_closure_len
            real(C_DOUBLE), value, intent(IN) :: cut
            integer(C_INT), value, intent(IN) :: mdiis_nvec
            real(C_DOUBLE), value, intent(IN) :: mdiis_del
            integer(C_INT), value, intent(IN) :: mdiis_method
            real(C_DOUBLE), value, intent(IN) :: mdiis_restart
            logical(C_BOOL), value, intent(IN) :: treeDCF
            logical(C_BOOL), value, intent(IN) :: treeTCF
            logical(C_BOOL), value, intent(IN) :: treeCoulomb
            real(C_DOUBLE), value, intent(IN) :: treeDCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeTCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeCoulombMAC
            integer(C_INT), value, intent(IN) :: treeDCFOrder
            integer(C_INT), value, intent(IN) :: treeTCFOrder
            integer(C_INT), value, intent(IN) :: treeCoulombOrder
            integer(C_INT), value, intent(IN) :: treeDCFN0
            integer(C_INT), value, intent(IN) :: treeTCFN0
            integer(C_INT), value, intent(IN) :: treeCoulombN0
            real(C_DOUBLE), value, intent(IN) :: asympKSpaceTolerance
            real(C_DOUBLE), value, intent(IN) :: ljTolerance
            real(C_DOUBLE), value, intent(IN) :: chargeSmear
            real(C_DOUBLE), value, intent(IN) :: o_buffer
            real(C_DOUBLE), intent(INOUT) :: o_grdspc(*)
            integer(C_INT), value, intent(IN) :: o_mpicomm
            character(kind=C_CHAR), intent(INOUT) :: o_periodic(*)
            integer(C_INT), value, intent(IN) :: SHT_o_periodic_len
            real(C_DOUBLE), intent(INOUT) :: o_unitCellDimensions(*)
            real(C_DOUBLE), value, intent(IN) :: o_biasPotential
            type(RIS_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_rism3d_new_0_bufferify

        function c_rism3d_new_1(solu_f, solv_f, centering, ncuvsteps, &
                closure, cut, mdiis_nvec, mdiis_del, mdiis_method, &
                mdiis_restart, treeDCF, treeTCF, treeCoulomb, &
                treeDCFMAC, treeTCFMAC, treeCoulombMAC, treeDCFOrder, &
                treeTCFOrder, treeCoulombOrder, treeDCFN0, treeTCFN0, &
                treeCoulombN0, asympKSpaceTolerance, ljTolerance, &
                chargeSmear, o_boxlen, o_ng3, o_mpicomm, o_periodic, &
                o_unitCellDimensions, o_biasPotential, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="RIS_rism3d_c_rism3d_new_1")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_DOUBLE, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data, solute_cpp, solvent_cpp
            implicit none
            type(solute_cpp), intent(INOUT) :: solu_f
            type(solvent_cpp), intent(INOUT) :: solv_f
            integer(C_INT), value, intent(IN) :: centering
            integer(C_INT), value, intent(IN) :: ncuvsteps
            type(C_PTR), intent(IN) :: closure(*)
            real(C_DOUBLE), value, intent(IN) :: cut
            integer(C_INT), value, intent(IN) :: mdiis_nvec
            real(C_DOUBLE), value, intent(IN) :: mdiis_del
            integer(C_INT), value, intent(IN) :: mdiis_method
            real(C_DOUBLE), value, intent(IN) :: mdiis_restart
            logical(C_BOOL), value, intent(IN) :: treeDCF
            logical(C_BOOL), value, intent(IN) :: treeTCF
            logical(C_BOOL), value, intent(IN) :: treeCoulomb
            real(C_DOUBLE), value, intent(IN) :: treeDCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeTCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeCoulombMAC
            integer(C_INT), value, intent(IN) :: treeDCFOrder
            integer(C_INT), value, intent(IN) :: treeTCFOrder
            integer(C_INT), value, intent(IN) :: treeCoulombOrder
            integer(C_INT), value, intent(IN) :: treeDCFN0
            integer(C_INT), value, intent(IN) :: treeTCFN0
            integer(C_INT), value, intent(IN) :: treeCoulombN0
            real(C_DOUBLE), value, intent(IN) :: asympKSpaceTolerance
            real(C_DOUBLE), value, intent(IN) :: ljTolerance
            real(C_DOUBLE), value, intent(IN) :: chargeSmear
            real(C_DOUBLE), intent(INOUT) :: o_boxlen(*)
            integer(C_INT), intent(INOUT) :: o_ng3(*)
            integer(C_INT), value, intent(IN) :: o_mpicomm
            character(kind=C_CHAR), intent(INOUT) :: o_periodic(*)
            real(C_DOUBLE), intent(INOUT) :: o_unitCellDimensions(*)
            real(C_DOUBLE), value, intent(IN) :: o_biasPotential
            type(RIS_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_rism3d_new_1

        function c_rism3d_new_1_bufferify(solu_f, solv_f, centering, &
                ncuvsteps, closure, SHT_closure_size, SHT_closure_len, &
                cut, mdiis_nvec, mdiis_del, mdiis_method, mdiis_restart, &
                treeDCF, treeTCF, treeCoulomb, treeDCFMAC, treeTCFMAC, &
                treeCoulombMAC, treeDCFOrder, treeTCFOrder, &
                treeCoulombOrder, treeDCFN0, treeTCFN0, treeCoulombN0, &
                asympKSpaceTolerance, ljTolerance, chargeSmear, &
                o_boxlen, o_ng3, o_mpicomm, o_periodic, &
                SHT_o_periodic_len, o_unitCellDimensions, &
                o_biasPotential, SHT_rv) &
                result(SHT_prv) &
                bind(C, name="RIS_rism3d_c_rism3d_new_1_bufferify")
            use iso_c_binding, only : C_BOOL, C_CHAR, C_DOUBLE, C_INT, C_PTR, C_SIZE_T
            import :: RIS_SHROUD_capsule_data, solute_cpp, solvent_cpp
            implicit none
            type(solute_cpp), intent(INOUT) :: solu_f
            type(solvent_cpp), intent(INOUT) :: solv_f
            integer(C_INT), value, intent(IN) :: centering
            integer(C_INT), value, intent(IN) :: ncuvsteps
            character(kind=C_CHAR), intent(IN) :: closure(*)
            integer(C_SIZE_T), intent(IN), value :: SHT_closure_size
            integer(C_INT), intent(IN), value :: SHT_closure_len
            real(C_DOUBLE), value, intent(IN) :: cut
            integer(C_INT), value, intent(IN) :: mdiis_nvec
            real(C_DOUBLE), value, intent(IN) :: mdiis_del
            integer(C_INT), value, intent(IN) :: mdiis_method
            real(C_DOUBLE), value, intent(IN) :: mdiis_restart
            logical(C_BOOL), value, intent(IN) :: treeDCF
            logical(C_BOOL), value, intent(IN) :: treeTCF
            logical(C_BOOL), value, intent(IN) :: treeCoulomb
            real(C_DOUBLE), value, intent(IN) :: treeDCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeTCFMAC
            real(C_DOUBLE), value, intent(IN) :: treeCoulombMAC
            integer(C_INT), value, intent(IN) :: treeDCFOrder
            integer(C_INT), value, intent(IN) :: treeTCFOrder
            integer(C_INT), value, intent(IN) :: treeCoulombOrder
            integer(C_INT), value, intent(IN) :: treeDCFN0
            integer(C_INT), value, intent(IN) :: treeTCFN0
            integer(C_INT), value, intent(IN) :: treeCoulombN0
            real(C_DOUBLE), value, intent(IN) :: asympKSpaceTolerance
            real(C_DOUBLE), value, intent(IN) :: ljTolerance
            real(C_DOUBLE), value, intent(IN) :: chargeSmear
            real(C_DOUBLE), intent(INOUT) :: o_boxlen(*)
            integer(C_INT), intent(INOUT) :: o_ng3(*)
            integer(C_INT), value, intent(IN) :: o_mpicomm
            character(kind=C_CHAR), intent(INOUT) :: o_periodic(*)
            integer(C_INT), value, intent(IN) :: SHT_o_periodic_len
            real(C_DOUBLE), intent(INOUT) :: o_unitCellDimensions(*)
            real(C_DOUBLE), value, intent(IN) :: o_biasPotential
            type(RIS_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            type(C_PTR) :: SHT_prv
        end function c_rism3d_new_1_bufferify

        subroutine c_rism3d_delete(self) &
                bind(C, name="RIS_rism3d_c_rism3d_delete")
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(INOUT) :: self
        end subroutine c_rism3d_delete

        subroutine c_rism3d_createelectrondensitymap(self, iv, &
                electronRDF, electronRDFGridSpacing, &
                totalSolventElectrons, density, electronmap_ptr) &
                bind(C, name="RIS_rism3d_c_rism3d_createelectrondensitymap")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: iv
            real(C_DOUBLE), intent(IN) :: electronRDF(*)
            real(C_DOUBLE), value, intent(IN) :: electronRDFGridSpacing
            integer(C_INT), value, intent(IN) :: totalSolventElectrons
            real(C_DOUBLE), value, intent(IN) :: density
            real(C_DOUBLE), intent(OUT) :: electronmap_ptr(*)
        end subroutine c_rism3d_createelectrondensitymap

        function c_rism3d_get_spacing(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_spacing")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_spacing

        subroutine c_rism3d_get_spacing_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_spacing_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_spacing_bufferify

        function c_rism3d_get_voxelvectorsr(self, len1, len2) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_voxelvectorsr")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len1
            integer(C_INT), intent(INOUT) :: len2
            type(C_PTR) SHT_rv
        end function c_rism3d_get_voxelvectorsr

        subroutine c_rism3d_get_voxelvectorsr_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_voxelvectorsr_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_voxelvectorsr_bufferify

        function c_rism3d_get_unitcellangles(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_unitcellangles")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_unitcellangles

        subroutine c_rism3d_get_unitcellangles_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_unitcellangles_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_unitcellangles_bufferify

        function c_rism3d_get_unitcellvectorsk(self, len1, len2) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_unitcellvectorsk")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len1
            integer(C_INT), intent(INOUT) :: len2
            type(C_PTR) SHT_rv
        end function c_rism3d_get_unitcellvectorsk

        subroutine c_rism3d_get_unitcellvectorsk_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_unitcellvectorsk_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_unitcellvectorsk_bufferify

        function c_rism3d_get_unitcellvectorsr(self, len1, len2) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_unitcellvectorsr")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len1
            integer(C_INT), intent(INOUT) :: len2
            type(C_PTR) SHT_rv
        end function c_rism3d_get_unitcellvectorsr

        subroutine c_rism3d_get_unitcellvectorsr_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_unitcellvectorsr_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_unitcellvectorsr_bufferify

        function c_rism3d_get_boxlength(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_boxlength")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_boxlength

        subroutine c_rism3d_get_boxlength_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_boxlength_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_boxlength_bufferify

        function c_rism3d_get_totallocalpointsr(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_totallocalpointsr")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_rism3d_get_totallocalpointsr

        subroutine c_rism3d_set_nsolution(self, nsol) &
                bind(C, name="RIS_rism3d_c_rism3d_set_nsolution")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: nsol
        end subroutine c_rism3d_set_nsolution

        function c_rism3d_get_nsolution(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_nsolution")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_rism3d_get_nsolution

        function c_rism3d_get_voxelvolume(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_voxelvolume")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_voxelvolume

        function c_rism3d_get_localdimsr_0(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_localdimsr_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_localdimsr_0

        subroutine c_rism3d_get_localdimsr_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_localdimsr_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_localdimsr_0_bufferify

        function c_rism3d_get_localdimsr_1(self, indx) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_localdimsr_1")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: indx
            integer(C_INT) :: SHT_rv
        end function c_rism3d_get_localdimsr_1

        function c_rism3d_get_globaldimsr_0(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_globaldimsr_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_globaldimsr_0

        subroutine c_rism3d_get_globaldimsr_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_globaldimsr_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_globaldimsr_0_bufferify

        function c_rism3d_get_globaldimsr_1(self, indx) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_globaldimsr_1")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: indx
            integer(C_INT) :: SHT_rv
        end function c_rism3d_get_globaldimsr_1

        subroutine c_rism3d_get_atomname(self, names, name_len) &
                bind(C, name="RIS_rism3d_c_rism3d_get_atomname")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR), intent(OUT) :: names
            integer(C_INT), intent(OUT) :: name_len
        end subroutine c_rism3d_get_atomname

        subroutine c_rism3d_get_atomname_bufferify(self, &
                SHT_names_cdesc) &
                bind(C, name="RIS_rism3d_c_rism3d_get_atomname_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_names_cdesc
        end subroutine c_rism3d_get_atomname_bufferify

        function c_rism3d_get_xikt_dt(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_xikt_dt")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_xikt_dt

        function c_rism3d_get_temperature(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_temperature")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_temperature

        function c_rism3d_get_charge_0(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_charge_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_charge_0

        subroutine c_rism3d_get_charge_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_charge_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_charge_0_bufferify

        function c_rism3d_get_charge_1(self, indx) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_charge_1")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: indx
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_charge_1

        function c_rism3d_get_density_0(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_density_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_density_0

        subroutine c_rism3d_get_density_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_density_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_density_0_bufferify

        function c_rism3d_get_density_1(self, indx) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_density_1")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: indx
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_density_1

        function c_rism3d_get_ionic(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_ionic")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_get_ionic

        function c_rism3d_get_centerofmass(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_centerofmass")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_centerofmass

        subroutine c_rism3d_get_centerofmass_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_centerofmass_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_centerofmass_bufferify

        function c_rism3d_get_translation(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_translation")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_get_translation

        subroutine c_rism3d_get_translation_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_translation_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_translation_bufferify

        function c_rism3d_get_charged(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_charged")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_get_charged

        function c_rism3d_get_mass(self, dim1) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_mass")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            type(C_PTR) SHT_rv
        end function c_rism3d_get_mass

        subroutine c_rism3d_get_mass_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_mass_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_mass_bufferify

        function c_rism3d_get_guv_0(self, dim1, dim2, arg1, arg2) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            type(C_PTR) SHT_rv
        end function c_rism3d_get_guv_0

        subroutine c_rism3d_get_guv_0_bufferify(self, arg1, arg2, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_0_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_guv_0_bufferify

        function c_rism3d_get_guv_1(self, dim1, dim2, arg) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_1")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), value, intent(IN) :: arg
            type(C_PTR) SHT_rv
        end function c_rism3d_get_guv_1

        subroutine c_rism3d_get_guv_1_bufferify(self, arg, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_1_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_guv_1_bufferify

        function c_rism3d_get_huv_0(self, dim1, dim2, arg1, arg2) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_huv_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            type(C_PTR) SHT_rv
        end function c_rism3d_get_huv_0

        subroutine c_rism3d_get_huv_0_bufferify(self, arg1, arg2, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_huv_0_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_huv_0_bufferify

        function c_rism3d_get_huv_1(self, dim1, dim2, arg) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_huv_1")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), value, intent(IN) :: arg
            type(C_PTR) SHT_rv
        end function c_rism3d_get_huv_1

        subroutine c_rism3d_get_huv_1_bufferify(self, arg, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_huv_1_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_huv_1_bufferify

        function c_rism3d_get_cuv_0(self, arg1, arg2, arg3, arg4) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_cuv_0")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            integer(C_INT), value, intent(IN) :: arg3
            integer(C_INT), value, intent(IN) :: arg4
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_cuv_0

        function c_rism3d_get_cuv_1(self, dim1, dim2, dim3, dim4, arg) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_cuv_1")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            integer(C_INT), intent(OUT) :: dim4
            integer(C_INT), value, intent(IN) :: arg
            type(C_PTR) SHT_rv
        end function c_rism3d_get_cuv_1

        subroutine c_rism3d_get_cuv_1_bufferify(self, arg, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_cuv_1_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_cuv_1_bufferify

        function c_rism3d_get_guv_dt_0(self, dim, arg) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_dt_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim
            integer(C_INT), value, intent(IN) :: arg
            type(C_PTR) SHT_rv
        end function c_rism3d_get_guv_dt_0

        subroutine c_rism3d_get_guv_dt_0_bufferify(self, arg, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_dt_0_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_guv_dt_0_bufferify

        function c_rism3d_get_guv_dt_1(self, dim, arg1, arg2) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_dt_1")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            type(C_PTR) SHT_rv
        end function c_rism3d_get_guv_dt_1

        subroutine c_rism3d_get_guv_dt_1_bufferify(self, arg1, arg2, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_guv_dt_1_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: arg1
            integer(C_INT), value, intent(IN) :: arg2
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_guv_dt_1_bufferify

        function c_rism3d_get_electronmap(self, dim1, dim2, dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_electronmap")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_get_electronmap

        subroutine c_rism3d_get_electronmap_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_electronmap_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_electronmap_bufferify

        function c_rism3d_get_tcflongrangeasympr(self, dim1) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_tcflongrangeasympr")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            type(C_PTR) SHT_rv
        end function c_rism3d_get_tcflongrangeasympr

        subroutine c_rism3d_get_tcflongrangeasympr_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_tcflongrangeasympr_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_tcflongrangeasympr_bufferify

        function c_rism3d_get_dcflongrangeasympr_0(self, dim1) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_dcflongrangeasympr_0")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            type(C_PTR) SHT_rv
        end function c_rism3d_get_dcflongrangeasympr_0

        subroutine c_rism3d_get_dcflongrangeasympr_0_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_dcflongrangeasympr_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_dcflongrangeasympr_0_bufferify

        function c_rism3d_get_dcflongrangeasympr_1(self, indx) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_dcflongrangeasympr_1")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: indx
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_get_dcflongrangeasympr_1

        function c_rism3d_get_uuv(self, dim1, dim2, dim3, dim4, indx) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_uuv")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            integer(C_INT), intent(OUT) :: dim4
            integer(C_INT), value, intent(IN) :: indx
            type(C_PTR) SHT_rv
        end function c_rism3d_get_uuv

        subroutine c_rism3d_get_uuv_bufferify(self, indx, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_uuv_bufferify")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: indx
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_get_uuv_bufferify

        function c_rism3d_get_periodic(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_periodic")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_get_periodic

        function c_rism3d_get_failure(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_failure")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_get_failure

        subroutine c_rism3d_set_atomname(self, names) &
                bind(C, name="RIS_rism3d_c_rism3d_set_atomname")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR), intent(IN) :: names(*)
        end subroutine c_rism3d_set_atomname

        subroutine c_rism3d_set_atomname_bufferify(self, names, &
                SHT_names_size, SHT_names_len) &
                bind(C, name="RIS_rism3d_c_rism3d_set_atomname_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT, C_SIZE_T
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            character(kind=C_CHAR), intent(IN) :: names(*)
            integer(C_SIZE_T), intent(IN), value :: SHT_names_size
            integer(C_INT), intent(IN), value :: SHT_names_len
        end subroutine c_rism3d_set_atomname_bufferify

        subroutine c_rism3d_setverbosity(self, verbosity) &
                bind(C, name="RIS_rism3d_c_rism3d_setverbosity")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: verbosity
        end subroutine c_rism3d_setverbosity

        subroutine c_rism3d_settimerparent(self, timer) &
                bind(C, name="RIS_rism3d_c_rism3d_settimerparent")
            import :: RIS_SHROUD_capsule_data, timer_cpp
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(timer_cpp), intent(INOUT) :: timer
        end subroutine c_rism3d_settimerparent

        subroutine c_rism3d_setcoord(self, solutePositions) &
                bind(C, name="RIS_rism3d_c_rism3d_setcoord")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(IN) :: solutePositions(*)
        end subroutine c_rism3d_setcoord

        function c_rism3d_calculatesolution(self, ksave, kshow, &
                maxSteps, failure, tolerance, tol_size) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_calculatesolution")
            use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: ksave
            integer(C_INT), value, intent(IN) :: kshow
            integer(C_INT), value, intent(IN) :: maxSteps
            logical(C_BOOL), value, intent(IN) :: failure
            real(C_DOUBLE), intent(INOUT) :: tolerance(*)
            integer(C_INT), value, intent(IN) :: tol_size
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_calculatesolution

        subroutine c_rism3d_force(self, ff) &
                bind(C, name="RIS_rism3d_c_rism3d_force")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: ff(*)
        end subroutine c_rism3d_force

        function c_rism3d_excesschemicalpotential_tot_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_tot_0")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_excesschemicalpotential_tot_0

        function c_rism3d_excesschemicalpotential_tot_1(self, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_tot_1")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_excesschemicalpotential_tot_1

        function c_rism3d_excesschemicalpotential_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotential_0

        subroutine c_rism3d_excesschemicalpotential_0_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotential_0_bufferify

        function c_rism3d_excesschemicalpotential_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotential_1

        subroutine c_rism3d_excesschemicalpotential_1_bufferify(self, &
                o_lr, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotential_1_bufferify

        function c_rism3d_excesschemicalpotentialgf_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotentialgf_0

        subroutine c_rism3d_excesschemicalpotentialgf_0_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotentialgf_0_bufferify

        function c_rism3d_excesschemicalpotentialgf_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotentialgf_1

        subroutine c_rism3d_excesschemicalpotentialgf_1_bufferify(self, &
                o_lr, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotentialgf_1_bufferify

        function c_rism3d_excesschemicalpotentialpcplus_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialpcplus_0")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_excesschemicalpotentialpcplus_0

        function c_rism3d_excesschemicalpotentialpcplus_1(self, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialpcplus_1")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_excesschemicalpotentialpcplus_1

        function c_rism3d_excesschemicalpotentialuc_0(self, coeff) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialuc_0")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: coeff(*)
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_excesschemicalpotentialuc_0

        function c_rism3d_excesschemicalpotentialuc_1(self, coeff, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialuc_1")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: coeff(*)
            logical(C_BOOL), value, intent(IN) :: o_lr
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_excesschemicalpotentialuc_1

        function c_rism3d_excesschemicalpotential_tot_map(self, dim1, &
                dim2, dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotential_tot_map

        subroutine c_rism3d_excesschemicalpotential_tot_map_bufferify( &
                self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotential_tot_map_bufferify

        function c_rism3d_excesschemicalpotentialgf_tot_map(self, dim1, &
                dim2, dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotentialgf_tot_map

        subroutine c_rism3d_excesschemicalpotentialgf_tot_map_bufferify( &
                self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotentialgf_tot_map_bufferify

        function c_rism3d_excesschemicalpotentialpcplus_tot_map(self, &
                dim1, dim2, dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialpcplus_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotentialpcplus_tot_map

        subroutine c_rism3d_excesschemicalpotentialpcplus_tot_map_bufferify( &
                self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialpcplus_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotentialpcplus_tot_map_bufferify

        function c_rism3d_excesschemicalpotentialuc_tot_map(self, dim1, &
                dim2, dim3, coeff) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialuc_tot_map")
            use iso_c_binding, only : C_DOUBLE, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            real(C_DOUBLE), intent(IN) :: coeff(*)
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotentialuc_tot_map

        subroutine c_rism3d_excesschemicalpotentialuc_tot_map_bufferify( &
                self, coeff, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialuc_tot_map_bufferify")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(IN) :: coeff(*)
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotentialuc_tot_map_bufferify

        function c_rism3d_solventpotene_tot_map(self, dim1, dim2, dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solventpotene_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_solventpotene_tot_map

        subroutine c_rism3d_solventpotene_tot_map_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solventpotene_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solventpotene_tot_map_bufferify

        function c_rism3d_solvationenergy_tot_map(self, dim1, dim2, &
                dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergy_tot_map

        subroutine c_rism3d_solvationenergy_tot_map_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergy_tot_map_bufferify

        function c_rism3d_solvationenergygf_tot_map(self, dim1, dim2, &
                dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergygf_tot_map

        subroutine c_rism3d_solvationenergygf_tot_map_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergygf_tot_map_bufferify

        function c_rism3d_solvationenergypcplus_tot_map(self, dim1, &
                dim2, dim3) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergypcplus_tot_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergypcplus_tot_map

        subroutine c_rism3d_solvationenergypcplus_tot_map_bufferify( &
                self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergypcplus_tot_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergypcplus_tot_map_bufferify

        function c_rism3d_solvationenergyuc_tot_map(self, dim1, dim2, &
                dim3, coeff) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergyuc_tot_map")
            use iso_c_binding, only : C_DOUBLE, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            real(C_DOUBLE), intent(IN) :: coeff(*)
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergyuc_tot_map

        subroutine c_rism3d_solvationenergyuc_tot_map_bufferify(self, &
                coeff, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergyuc_tot_map_bufferify")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(IN) :: coeff(*)
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergyuc_tot_map_bufferify

        function c_rism3d_excesschemicalpotential_site_map(self, dim1, &
                dim2, dim3, dim4) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_site_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            integer(C_INT), intent(OUT) :: dim4
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotential_site_map

        subroutine c_rism3d_excesschemicalpotential_site_map_bufferify( &
                self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotential_site_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotential_site_map_bufferify

        function c_rism3d_excesschemicalpotentialgf_site_map(self, dim1, &
                dim2, dim3, dim4) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_site_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            integer(C_INT), intent(OUT) :: dim4
            type(C_PTR) SHT_rv
        end function c_rism3d_excesschemicalpotentialgf_site_map

        subroutine c_rism3d_excesschemicalpotentialgf_site_map_bufferify( &
                self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excesschemicalpotentialgf_site_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excesschemicalpotentialgf_site_map_bufferify

        function c_rism3d_solventpotene_site_map(self, dim1, dim2, dim3, &
                dim4) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solventpotene_site_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            integer(C_INT), intent(OUT) :: dim4
            type(C_PTR) SHT_rv
        end function c_rism3d_solventpotene_site_map

        subroutine c_rism3d_solventpotene_site_map_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solventpotene_site_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solventpotene_site_map_bufferify

        function c_rism3d_solvationenergy_site_map(self, dim1, dim2, &
                dim3, dim4) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_site_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: dim1
            integer(C_INT), intent(OUT) :: dim2
            integer(C_INT), intent(OUT) :: dim3
            integer(C_INT), intent(OUT) :: dim4
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergy_site_map

        subroutine c_rism3d_solvationenergy_site_map_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_site_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergy_site_map_bufferify

        function c_rism3d_solventpotene(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solventpotene")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_solventpotene

        subroutine c_rism3d_solventpotene_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solventpotene_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solventpotene_bufferify

        function c_rism3d_partialmolarvolume(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_partialmolarvolume")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_partialmolarvolume

        function c_rism3d_excessparticles_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_excessparticles_0

        subroutine c_rism3d_excessparticles_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excessparticles_0_bufferify

        function c_rism3d_excessparticles_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_excessparticles_1

        subroutine c_rism3d_excessparticles_1_bufferify(self, o_lr, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excessparticles_1_bufferify

        function c_rism3d_kirkwoodbuff_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_kirkwoodbuff_0

        subroutine c_rism3d_kirkwoodbuff_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_kirkwoodbuff_0_bufferify

        function c_rism3d_kirkwoodbuff_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_kirkwoodbuff_1

        subroutine c_rism3d_kirkwoodbuff_1_bufferify(self, o_lr, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_kirkwoodbuff_1_bufferify

        function c_rism3d_dcfintegral(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_dcfintegral")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_dcfintegral

        subroutine c_rism3d_dcfintegral_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_dcfintegral_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_dcfintegral_bufferify

        function c_rism3d_cancalc_dt(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_cancalc_dt")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_cancalc_dt

        function c_rism3d_calculatesolution_dt(self, kshow, maxSteps, &
                failure, tolerance) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_calculatesolution_dt")
            use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: kshow
            integer(C_INT), value, intent(IN) :: maxSteps
            logical(C_BOOL), value, intent(IN) :: failure
            real(C_DOUBLE), value, intent(IN) :: tolerance
            logical(C_BOOL) :: SHT_rv
        end function c_rism3d_calculatesolution_dt

        function c_rism3d_solvationenergy_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergy_0

        subroutine c_rism3d_solvationenergy_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergy_0_bufferify

        function c_rism3d_solvationenergy_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergy_1

        subroutine c_rism3d_solvationenergy_1_bufferify(self, o_lr, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergy_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergy_1_bufferify

        function c_rism3d_solvationenergygf_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergygf_0

        subroutine c_rism3d_solvationenergygf_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergygf_0_bufferify

        function c_rism3d_solvationenergygf_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergygf_1

        subroutine c_rism3d_solvationenergygf_1_bufferify(self, o_lr, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergygf_1_bufferify

        function c_rism3d_solvationenergygf_site_map(self, dim1, dim2, &
                dim3, dim4) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_site_map")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(INOUT) :: dim1
            integer(C_INT), intent(INOUT) :: dim2
            integer(C_INT), intent(INOUT) :: dim3
            integer(C_INT), intent(INOUT) :: dim4
            type(C_PTR) SHT_rv
        end function c_rism3d_solvationenergygf_site_map

        subroutine c_rism3d_solvationenergygf_site_map_bufferify(self, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergygf_site_map_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_solvationenergygf_site_map_bufferify

        function c_rism3d_excessparticles_dt_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_dt_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_excessparticles_dt_0

        subroutine c_rism3d_excessparticles_dt_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_dt_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excessparticles_dt_0_bufferify

        function c_rism3d_excessparticles_dt_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_dt_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_excessparticles_dt_1

        subroutine c_rism3d_excessparticles_dt_1_bufferify(self, o_lr, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_excessparticles_dt_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_excessparticles_dt_1_bufferify

        function c_rism3d_kirkwoodbuff_dt_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_dt_0")
            use iso_c_binding, only : C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR) SHT_rv
        end function c_rism3d_kirkwoodbuff_dt_0

        subroutine c_rism3d_kirkwoodbuff_dt_0_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_dt_0_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_kirkwoodbuff_dt_0_bufferify

        function c_rism3d_kirkwoodbuff_dt_1(self, len, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_dt_1")
            use iso_c_binding, only : C_BOOL, C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(C_PTR) SHT_rv
        end function c_rism3d_kirkwoodbuff_dt_1

        subroutine c_rism3d_kirkwoodbuff_dt_1_bufferify(self, o_lr, &
                SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_kirkwoodbuff_dt_1_bufferify")
            use iso_c_binding, only : C_BOOL
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_kirkwoodbuff_dt_1_bufferify

        function c_rism3d_dcfintegral_dt(self, len) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_dcfintegral_dt")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), intent(OUT) :: len
            type(C_PTR) SHT_rv
        end function c_rism3d_dcfintegral_dt

        subroutine c_rism3d_dcfintegral_dt_bufferify(self, SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_dcfintegral_dt_bufferify")
            import :: RIS_SHROUD_array, RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(RIS_SHROUD_array), intent(OUT) :: SHT_rv
        end subroutine c_rism3d_dcfintegral_dt_bufferify

        function c_rism3d_solvationenergypcplus_0(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergypcplus_0")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_solvationenergypcplus_0

        function c_rism3d_solvationenergypcplus_1(self, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergypcplus_1")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            logical(C_BOOL), value, intent(IN) :: o_lr
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_solvationenergypcplus_1

        function c_rism3d_solvationenergyuc_0(self, coeff) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergyuc_0")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: coeff(*)
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_solvationenergyuc_0

        function c_rism3d_solvationenergyuc_1(self, coeff, o_lr) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_solvationenergyuc_1")
            use iso_c_binding, only : C_BOOL, C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: coeff(*)
            logical(C_BOOL), value, intent(IN) :: o_lr
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_solvationenergyuc_1

        function c_rism3d_partialmolarvolume_dt(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_partialmolarvolume_dt")
            use iso_c_binding, only : C_DOUBLE
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE) :: SHT_rv
        end function c_rism3d_partialmolarvolume_dt

        subroutine c_rism3d_unsetcharges(self) &
                bind(C, name="RIS_rism3d_c_rism3d_unsetcharges")
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
        end subroutine c_rism3d_unsetcharges

        subroutine c_rism3d_resetcharges(self) &
                bind(C, name="RIS_rism3d_c_rism3d_resetcharges")
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
        end subroutine c_rism3d_resetcharges

        subroutine c_rism3d_map_site_to_site_flat(self, thermo_map_flat, &
                center_site) &
                bind(C, name="RIS_rism3d_c_rism3d_map_site_to_site_flat")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: thermo_map_flat(*)
            integer(C_INT), value, intent(IN) :: center_site
        end subroutine c_rism3d_map_site_to_site_flat

        subroutine c_rism3d_map_site_to_site_3_d(self, thermo_map, &
                center_site) &
                bind(C, name="RIS_rism3d_c_rism3d_map_site_to_site_3D")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            real(C_DOUBLE), intent(INOUT) :: thermo_map(*)
            integer(C_INT), value, intent(IN) :: center_site
        end subroutine c_rism3d_map_site_to_site_3_d

        subroutine c_rism3d_selftest(self) &
                bind(C, name="RIS_rism3d_c_rism3d_selftest")
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
        end subroutine c_rism3d_selftest

        subroutine c_rism3d_set_closurelist(self, names, N) &
                bind(C, name="RIS_rism3d_c_rism3d_set_closurelist")
            use iso_c_binding, only : C_INT, C_PTR
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            type(C_PTR), intent(IN) :: names(*)
            integer(C_INT), intent(IN) :: N
        end subroutine c_rism3d_set_closurelist

        subroutine c_rism3d_set_closurelist_bufferify(self, names, &
                SHT_names_size, SHT_names_len, N) &
                bind(C, name="RIS_rism3d_c_rism3d_set_closurelist_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT, C_SIZE_T
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            character(kind=C_CHAR), intent(IN) :: names(*)
            integer(C_SIZE_T), intent(IN), value :: SHT_names_size
            integer(C_INT), intent(IN), value :: SHT_names_len
            integer(C_INT), intent(IN) :: N
        end subroutine c_rism3d_set_closurelist_bufferify

        subroutine c_rism3d_print_tests(self) &
                bind(C, name="RIS_rism3d_c_rism3d_PrintTests")
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
        end subroutine c_rism3d_print_tests

        subroutine c_rism3d_opendx_write_cpp(self, atomType, file) &
                bind(C, name="RIS_rism3d_c_rism3d_opendx_write_cpp")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: atomType
            character(kind=C_CHAR), intent(IN) :: file(*)
        end subroutine c_rism3d_opendx_write_cpp

        subroutine c_rism3d_opendx_write_cpp_bufferify(self, atomType, &
                file, SHT_file_len) &
                bind(C, name="RIS_rism3d_c_rism3d_opendx_write_cpp_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: atomType
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT), value, intent(IN) :: SHT_file_len
        end subroutine c_rism3d_opendx_write_cpp_bufferify

        subroutine c_rism3d_mrc_map_write_cpp(self, atomType, file) &
                bind(C, name="RIS_rism3d_c_rism3d_mrc_map_write_cpp")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: atomType
            character(kind=C_CHAR), intent(IN) :: file(*)
        end subroutine c_rism3d_mrc_map_write_cpp

        subroutine c_rism3d_mrc_map_write_cpp_bufferify(self, atomType, &
                file, SHT_file_len) &
                bind(C, name="RIS_rism3d_c_rism3d_mrc_map_write_cpp_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: atomType
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT), value, intent(IN) :: SHT_file_len
        end subroutine c_rism3d_mrc_map_write_cpp_bufferify

        subroutine c_rism3d_xyzv_write_cpp(self, atomType, file) &
                bind(C, name="RIS_rism3d_c_rism3d_xyzv_write_cpp")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: atomType
            character(kind=C_CHAR), intent(IN) :: file(*)
        end subroutine c_rism3d_xyzv_write_cpp

        subroutine c_rism3d_xyzv_write_cpp_bufferify(self, atomType, &
                file, SHT_file_len) &
                bind(C, name="RIS_rism3d_c_rism3d_xyzv_write_cpp_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: atomType
            character(kind=C_CHAR), intent(IN) :: file(*)
            integer(C_INT), value, intent(IN) :: SHT_file_len
        end subroutine c_rism3d_xyzv_write_cpp_bufferify
    end interface

    interface rism3d
        module procedure rism3d_new_0
        module procedure rism3d_new_1
    end interface rism3d

    interface rism3d_excesschemicalpotential
        module procedure rism3d_excesschemicalpotential_0
        module procedure rism3d_excesschemicalpotential_1
    end interface rism3d_excesschemicalpotential

    interface rism3d_excesschemicalpotential_tot
        module procedure rism3d_excesschemicalpotential_tot_0
        module procedure rism3d_excesschemicalpotential_tot_1
    end interface rism3d_excesschemicalpotential_tot

    interface rism3d_excesschemicalpotentialgf
        module procedure rism3d_excesschemicalpotentialgf_0
        module procedure rism3d_excesschemicalpotentialgf_1
    end interface rism3d_excesschemicalpotentialgf

    interface rism3d_excesschemicalpotentialpcplus
        module procedure rism3d_excesschemicalpotentialpcplus_0
        module procedure rism3d_excesschemicalpotentialpcplus_1
    end interface rism3d_excesschemicalpotentialpcplus

    interface rism3d_excesschemicalpotentialuc
        module procedure rism3d_excesschemicalpotentialuc_0
        module procedure rism3d_excesschemicalpotentialuc_1
    end interface rism3d_excesschemicalpotentialuc

    interface rism3d_excessparticles
        module procedure rism3d_excessparticles_0
        module procedure rism3d_excessparticles_1
    end interface rism3d_excessparticles

    interface rism3d_excessparticles_dt
        module procedure rism3d_excessparticles_dt_0
        module procedure rism3d_excessparticles_dt_1
    end interface rism3d_excessparticles_dt

    interface rism3d_get_charge
        module procedure rism3d_get_charge_0
        module procedure rism3d_get_charge_1
    end interface rism3d_get_charge

    interface rism3d_get_cuv
        module procedure rism3d_get_cuv_0
        module procedure rism3d_get_cuv_1
    end interface rism3d_get_cuv

    interface rism3d_get_dcflongrangeasympr
        module procedure rism3d_get_dcflongrangeasympr_0
        module procedure rism3d_get_dcflongrangeasympr_1
    end interface rism3d_get_dcflongrangeasympr

    interface rism3d_get_density
        module procedure rism3d_get_density_0
        module procedure rism3d_get_density_1
    end interface rism3d_get_density

    interface rism3d_get_globaldimsr
        module procedure rism3d_get_globaldimsr_0
        module procedure rism3d_get_globaldimsr_1
    end interface rism3d_get_globaldimsr

    interface rism3d_get_guv
        module procedure rism3d_get_guv_0
        module procedure rism3d_get_guv_1
    end interface rism3d_get_guv

    interface rism3d_get_guv_dt
        module procedure rism3d_get_guv_dt_0
        module procedure rism3d_get_guv_dt_1
    end interface rism3d_get_guv_dt

    interface rism3d_get_huv
        module procedure rism3d_get_huv_0
        module procedure rism3d_get_huv_1
    end interface rism3d_get_huv

    interface rism3d_get_localdimsr
        module procedure rism3d_get_localdimsr_0
        module procedure rism3d_get_localdimsr_1
    end interface rism3d_get_localdimsr

    interface rism3d_kirkwoodbuff
        module procedure rism3d_kirkwoodbuff_0
        module procedure rism3d_kirkwoodbuff_1
    end interface rism3d_kirkwoodbuff

    interface rism3d_kirkwoodbuff_dt
        module procedure rism3d_kirkwoodbuff_dt_0
        module procedure rism3d_kirkwoodbuff_dt_1
    end interface rism3d_kirkwoodbuff_dt

    interface rism3d_solvationenergy
        module procedure rism3d_solvationenergy_0
        module procedure rism3d_solvationenergy_1
    end interface rism3d_solvationenergy

    interface rism3d_solvationenergygf
        module procedure rism3d_solvationenergygf_0
        module procedure rism3d_solvationenergygf_1
    end interface rism3d_solvationenergygf

    interface rism3d_solvationenergypcplus
        module procedure rism3d_solvationenergypcplus_0
        module procedure rism3d_solvationenergypcplus_1
    end interface rism3d_solvationenergypcplus

    interface rism3d_solvationenergyuc
        module procedure rism3d_solvationenergyuc_0
        module procedure rism3d_solvationenergyuc_1
    end interface rism3d_solvationenergyuc

    ! splicer begin namespace.rism3d_c.additional_declarations
    interface

        pure function c_rism3d_get_numatoms(self) &
                result(SHT_rv) &
                bind(C, name="RIS_rism3d_c_rism3d_get_numatoms")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_rism3d_get_numatoms

        pure function c_rism3d_get_numatomtypes(self) &
            result(SHT_rv) &
            bind(C, name="RIS_rism3d_c_rism3d_get_numatomtypes")
            use iso_c_binding, only : C_INT
            import :: RIS_SHROUD_capsule_data
            implicit none
            type(RIS_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_rism3d_get_numatomtypes

    end interface

    interface  rism3d_map_site_to_site
        module procedure rism3d_map_site_to_site_flat, rism3d_map_site_to_site_3_D
    end interface rism3d_map_site_to_site
    ! splicer end namespace.rism3d_c.additional_declarations

contains

    function rism3d_new_0(solu_f, solv_f, centering, ncuvsteps, closure, &
            cut, mdiis_nvec, mdiis_del, mdiis_method, mdiis_restart, &
            treeDCF, treeTCF, treeCoulomb, treeDCFMAC, treeTCFMAC, &
            treeCoulombMAC, treeDCFOrder, treeTCFOrder, &
            treeCoulombOrder, treeDCFN0, treeTCFN0, treeCoulombN0, &
            asympKSpaceTolerance, ljTolerance, chargeSmear, o_buffer, &
            o_grdspc, o_mpicomm, o_periodic, o_unitCellDimensions, &
            o_biasPotential) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT, C_PTR, C_SIZE_T
        type(solute_cpp), intent(INOUT) :: solu_f
        type(solvent_cpp), intent(INOUT) :: solv_f
        integer(C_INT), value, intent(IN) :: centering
        integer(C_INT), value, intent(IN) :: ncuvsteps
        character(len=*), intent(IN) :: closure(:)
        real(C_DOUBLE), value, intent(IN) :: cut
        integer(C_INT), value, intent(IN) :: mdiis_nvec
        real(C_DOUBLE), value, intent(IN) :: mdiis_del
        integer(C_INT), value, intent(IN) :: mdiis_method
        real(C_DOUBLE), value, intent(IN) :: mdiis_restart
        logical, value, intent(IN) :: treeDCF
        logical, value, intent(IN) :: treeTCF
        logical, value, intent(IN) :: treeCoulomb
        real(C_DOUBLE), value, intent(IN) :: treeDCFMAC
        real(C_DOUBLE), value, intent(IN) :: treeTCFMAC
        real(C_DOUBLE), value, intent(IN) :: treeCoulombMAC
        integer(C_INT), value, intent(IN) :: treeDCFOrder
        integer(C_INT), value, intent(IN) :: treeTCFOrder
        integer(C_INT), value, intent(IN) :: treeCoulombOrder
        integer(C_INT), value, intent(IN) :: treeDCFN0
        integer(C_INT), value, intent(IN) :: treeTCFN0
        integer(C_INT), value, intent(IN) :: treeCoulombN0
        real(C_DOUBLE), value, intent(IN) :: asympKSpaceTolerance
        real(C_DOUBLE), value, intent(IN) :: ljTolerance
        real(C_DOUBLE), value, intent(IN) :: chargeSmear
        real(C_DOUBLE), value, intent(IN) :: o_buffer
        real(C_DOUBLE), intent(INOUT) :: o_grdspc(:)
        integer(C_INT), value, intent(IN) :: o_mpicomm
        character(len=*), intent(INOUT) :: o_periodic
        real(C_DOUBLE), intent(INOUT) :: o_unitCellDimensions(:)
        real(C_DOUBLE), value, intent(IN) :: o_biasPotential
        type(rism3d) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.new_0
        logical(C_BOOL) :: SHT_treeDCF_cxx
        logical(C_BOOL) :: SHT_treeTCF_cxx
        logical(C_BOOL) :: SHT_treeCoulomb_cxx
        integer(C_INT) SHT_o_periodic_len
        SHT_treeDCF_cxx = treeDCF  ! coerce to C_BOOL
        SHT_treeTCF_cxx = treeTCF  ! coerce to C_BOOL
        SHT_treeCoulomb_cxx = treeCoulomb  ! coerce to C_BOOL
        SHT_o_periodic_len = len(o_periodic, kind=C_INT)
        SHT_prv = c_rism3d_new_0_bufferify(solu_f, solv_f, centering, &
            ncuvsteps, closure, size(closure, kind=C_SIZE_T), &
            len(closure, kind=C_INT), cut, mdiis_nvec, mdiis_del, &
            mdiis_method, mdiis_restart, SHT_treeDCF_cxx, &
            SHT_treeTCF_cxx, SHT_treeCoulomb_cxx, treeDCFMAC, &
            treeTCFMAC, treeCoulombMAC, treeDCFOrder, treeTCFOrder, &
            treeCoulombOrder, treeDCFN0, treeTCFN0, treeCoulombN0, &
            asympKSpaceTolerance, ljTolerance, chargeSmear, o_buffer, &
            o_grdspc, o_mpicomm, o_periodic, SHT_o_periodic_len, &
            o_unitCellDimensions, o_biasPotential, SHT_rv%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.new_0
    end function rism3d_new_0

    function rism3d_new_1(solu_f, solv_f, centering, ncuvsteps, closure, &
            cut, mdiis_nvec, mdiis_del, mdiis_method, mdiis_restart, &
            treeDCF, treeTCF, treeCoulomb, treeDCFMAC, treeTCFMAC, &
            treeCoulombMAC, treeDCFOrder, treeTCFOrder, &
            treeCoulombOrder, treeDCFN0, treeTCFN0, treeCoulombN0, &
            asympKSpaceTolerance, ljTolerance, chargeSmear, o_boxlen, &
            o_ng3, o_mpicomm, o_periodic, o_unitCellDimensions, &
            o_biasPotential) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT, C_PTR, C_SIZE_T
        type(solute_cpp), intent(INOUT) :: solu_f
        type(solvent_cpp), intent(INOUT) :: solv_f
        integer(C_INT), value, intent(IN) :: centering
        integer(C_INT), value, intent(IN) :: ncuvsteps
        character(len=*), intent(IN) :: closure(:)
        real(C_DOUBLE), value, intent(IN) :: cut
        integer(C_INT), value, intent(IN) :: mdiis_nvec
        real(C_DOUBLE), value, intent(IN) :: mdiis_del
        integer(C_INT), value, intent(IN) :: mdiis_method
        real(C_DOUBLE), value, intent(IN) :: mdiis_restart
        logical, value, intent(IN) :: treeDCF
        logical, value, intent(IN) :: treeTCF
        logical, value, intent(IN) :: treeCoulomb
        real(C_DOUBLE), value, intent(IN) :: treeDCFMAC
        real(C_DOUBLE), value, intent(IN) :: treeTCFMAC
        real(C_DOUBLE), value, intent(IN) :: treeCoulombMAC
        integer(C_INT), value, intent(IN) :: treeDCFOrder
        integer(C_INT), value, intent(IN) :: treeTCFOrder
        integer(C_INT), value, intent(IN) :: treeCoulombOrder
        integer(C_INT), value, intent(IN) :: treeDCFN0
        integer(C_INT), value, intent(IN) :: treeTCFN0
        integer(C_INT), value, intent(IN) :: treeCoulombN0
        real(C_DOUBLE), value, intent(IN) :: asympKSpaceTolerance
        real(C_DOUBLE), value, intent(IN) :: ljTolerance
        real(C_DOUBLE), value, intent(IN) :: chargeSmear
        real(C_DOUBLE), intent(INOUT) :: o_boxlen(:)
        integer(C_INT), intent(INOUT) :: o_ng3(:)
        integer(C_INT), value, intent(IN) :: o_mpicomm
        character(len=*), intent(INOUT) :: o_periodic
        real(C_DOUBLE), intent(INOUT) :: o_unitCellDimensions(:)
        real(C_DOUBLE), value, intent(IN) :: o_biasPotential
        type(rism3d) :: SHT_rv
        type(C_PTR) :: SHT_prv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.new_1
        logical(C_BOOL) :: SHT_treeDCF_cxx
        logical(C_BOOL) :: SHT_treeTCF_cxx
        logical(C_BOOL) :: SHT_treeCoulomb_cxx
        integer(C_INT) SHT_o_periodic_len
        SHT_treeDCF_cxx = treeDCF  ! coerce to C_BOOL
        SHT_treeTCF_cxx = treeTCF  ! coerce to C_BOOL
        SHT_treeCoulomb_cxx = treeCoulomb  ! coerce to C_BOOL
        SHT_o_periodic_len = len(o_periodic, kind=C_INT)
        SHT_prv = c_rism3d_new_1_bufferify(solu_f, solv_f, centering, &
            ncuvsteps, closure, size(closure, kind=C_SIZE_T), &
            len(closure, kind=C_INT), cut, mdiis_nvec, mdiis_del, &
            mdiis_method, mdiis_restart, SHT_treeDCF_cxx, &
            SHT_treeTCF_cxx, SHT_treeCoulomb_cxx, treeDCFMAC, &
            treeTCFMAC, treeCoulombMAC, treeDCFOrder, treeTCFOrder, &
            treeCoulombOrder, treeDCFN0, treeTCFN0, treeCoulombN0, &
            asympKSpaceTolerance, ljTolerance, chargeSmear, o_boxlen, &
            o_ng3, o_mpicomm, o_periodic, SHT_o_periodic_len, &
            o_unitCellDimensions, o_biasPotential, SHT_rv%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.new_1
    end function rism3d_new_1

    subroutine rism3d_delete(obj)
        class(rism3d) :: obj
        ! splicer begin namespace.rism3d_c.class.rism3d.method.delete
        call c_rism3d_delete(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.delete
    end subroutine rism3d_delete

    subroutine rism3d_createelectrondensitymap(obj, iv, electronRDF, &
            electronRDFGridSpacing, totalSolventElectrons, density, &
            electronmap_ptr)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: iv
        real(C_DOUBLE), intent(IN) :: electronRDF(:)
        real(C_DOUBLE), value, intent(IN) :: electronRDFGridSpacing
        integer(C_INT), value, intent(IN) :: totalSolventElectrons
        real(C_DOUBLE), value, intent(IN) :: density
        real(C_DOUBLE), intent(OUT) :: electronmap_ptr(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.createelectrondensitymap
        call c_rism3d_createelectrondensitymap(obj%cxxmem, iv, &
            electronRDF, electronRDFGridSpacing, totalSolventElectrons, &
            density, electronmap_ptr)
        ! splicer end namespace.rism3d_c.class.rism3d.method.createelectrondensitymap
    end subroutine rism3d_createelectrondensitymap

    function rism3d_get_spacing(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_spacing
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_spacing_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_spacing
    end function rism3d_get_spacing

    function rism3d_get_voxelvectorsr(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_voxelvectorsr
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_voxelvectorsr_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_voxelvectorsr
    end function rism3d_get_voxelvectorsr

    function rism3d_get_unitcellangles(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_unitcellangles
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_unitcellangles_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_unitcellangles
    end function rism3d_get_unitcellangles

    function rism3d_get_unitcellvectorsk(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_unitcellvectorsk
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_unitcellvectorsk_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_unitcellvectorsk
    end function rism3d_get_unitcellvectorsk

    function rism3d_get_unitcellvectorsr(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_unitcellvectorsr
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_unitcellvectorsr_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_unitcellvectorsr
    end function rism3d_get_unitcellvectorsr

    function rism3d_get_boxlength(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_boxlength
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_boxlength_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_boxlength
    end function rism3d_get_boxlength

    function rism3d_get_totallocalpointsr(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_totallocalpointsr
        SHT_rv = c_rism3d_get_totallocalpointsr(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_totallocalpointsr
    end function rism3d_get_totallocalpointsr

    subroutine rism3d_set_nsolution(obj, nsol)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: nsol
        ! splicer begin namespace.rism3d_c.class.rism3d.method.set_nsolution
        call c_rism3d_set_nsolution(obj%cxxmem, nsol)
        ! splicer end namespace.rism3d_c.class.rism3d.method.set_nsolution
    end subroutine rism3d_set_nsolution

    function rism3d_get_nsolution(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_nsolution
        SHT_rv = c_rism3d_get_nsolution(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_nsolution
    end function rism3d_get_nsolution

    function rism3d_get_voxelvolume(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_voxelvolume
        SHT_rv = c_rism3d_get_voxelvolume(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_voxelvolume
    end function rism3d_get_voxelvolume

    function rism3d_get_localdimsr_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_localdimsr_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_localdimsr_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_localdimsr_0
    end function rism3d_get_localdimsr_0

    function rism3d_get_localdimsr_1(obj, indx) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: indx
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_localdimsr_1
        SHT_rv = c_rism3d_get_localdimsr_1(obj%cxxmem, indx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_localdimsr_1
    end function rism3d_get_localdimsr_1

    function rism3d_get_globaldimsr_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_globaldimsr_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_globaldimsr_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_globaldimsr_0
    end function rism3d_get_globaldimsr_0

    function rism3d_get_globaldimsr_1(obj, indx) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: indx
        integer(C_INT) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_globaldimsr_1
        SHT_rv = c_rism3d_get_globaldimsr_1(obj%cxxmem, indx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_globaldimsr_1
    end function rism3d_get_globaldimsr_1

    subroutine rism3d_get_atomname(obj, names)
        use iso_c_binding, only : C_LOC
        class(rism3d) :: obj
        character(*), intent(OUT), target :: names(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_atomname
        type(RIS_SHROUD_array) :: SHT_names_cdesc
        SHT_names_cdesc%cxx%addr = C_LOC(names)
        SHT_names_cdesc%base_addr = C_LOC(names)
        SHT_names_cdesc%type = SH_TYPE_CHAR
        SHT_names_cdesc%elem_len = len(names)
        SHT_names_cdesc%size = size(names)
        SHT_names_cdesc%rank = rank(names)
        SHT_names_cdesc%shape(1:1) = shape(names)
        call c_rism3d_get_atomname_bufferify(obj%cxxmem, &
            SHT_names_cdesc)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_atomname
    end subroutine rism3d_get_atomname

    function rism3d_get_xikt_dt(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_xikt_dt
        SHT_rv = c_rism3d_get_xikt_dt(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_xikt_dt
    end function rism3d_get_xikt_dt

    function rism3d_get_temperature(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_temperature
        SHT_rv = c_rism3d_get_temperature(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_temperature
    end function rism3d_get_temperature

    function rism3d_get_charge_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_charge_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_charge_0_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_charge_0
    end function rism3d_get_charge_0

    function rism3d_get_charge_1(obj, indx) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: indx
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_charge_1
        SHT_rv = c_rism3d_get_charge_1(obj%cxxmem, indx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_charge_1
    end function rism3d_get_charge_1

    function rism3d_get_density_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_density_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_density_0_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_density_0
    end function rism3d_get_density_0

    function rism3d_get_density_1(obj, indx) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: indx
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_density_1
        SHT_rv = c_rism3d_get_density_1(obj%cxxmem, indx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_density_1
    end function rism3d_get_density_1

    function rism3d_get_ionic(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(rism3d) :: obj
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_ionic
        SHT_rv = c_rism3d_get_ionic(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_ionic
    end function rism3d_get_ionic

    function rism3d_get_centerofmass(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_centerofmass
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_centerofmass_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_centerofmass
    end function rism3d_get_centerofmass

    function rism3d_get_translation(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_translation
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_translation_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_translation
    end function rism3d_get_translation

    function rism3d_get_charged(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(rism3d) :: obj
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_charged
        SHT_rv = c_rism3d_get_charged(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_charged
    end function rism3d_get_charged

    function rism3d_get_mass(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_mass
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_mass_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_mass
    end function rism3d_get_mass

    function rism3d_get_guv_0(obj, arg1, arg2) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg1
        integer(C_INT), value, intent(IN) :: arg2
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_guv_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_guv_0_bufferify(obj%cxxmem, arg1, arg2, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_guv_0
    end function rism3d_get_guv_0

    function rism3d_get_guv_1(obj, arg) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_guv_1
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_guv_1_bufferify(obj%cxxmem, arg, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_guv_1
    end function rism3d_get_guv_1

    function rism3d_get_huv_0(obj, arg1, arg2) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg1
        integer(C_INT), value, intent(IN) :: arg2
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_huv_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_huv_0_bufferify(obj%cxxmem, arg1, arg2, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_huv_0
    end function rism3d_get_huv_0

    function rism3d_get_huv_1(obj, arg) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg
        real(C_DOUBLE), pointer :: SHT_rv(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_huv_1
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_huv_1_bufferify(obj%cxxmem, arg, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:2))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_huv_1
    end function rism3d_get_huv_1

    function rism3d_get_cuv_0(obj, arg1, arg2, arg3, arg4) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg1
        integer(C_INT), value, intent(IN) :: arg2
        integer(C_INT), value, intent(IN) :: arg3
        integer(C_INT), value, intent(IN) :: arg4
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_cuv_0
        SHT_rv = c_rism3d_get_cuv_0(obj%cxxmem, arg1, arg2, arg3, arg4)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_cuv_0
    end function rism3d_get_cuv_0

    function rism3d_get_cuv_1(obj, arg) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_cuv_1
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_cuv_1_bufferify(obj%cxxmem, arg, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_cuv_1
    end function rism3d_get_cuv_1

    function rism3d_get_guv_dt_0(obj, arg) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_guv_dt_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_guv_dt_0_bufferify(obj%cxxmem, arg, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_guv_dt_0
    end function rism3d_get_guv_dt_0

    function rism3d_get_guv_dt_1(obj, arg1, arg2) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: arg1
        integer(C_INT), value, intent(IN) :: arg2
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_guv_dt_1
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_guv_dt_1_bufferify(obj%cxxmem, arg1, arg2, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_guv_dt_1
    end function rism3d_get_guv_dt_1

    function rism3d_get_electronmap(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_electronmap
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_electronmap_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_electronmap
    end function rism3d_get_electronmap

    function rism3d_get_tcflongrangeasympr(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_tcflongrangeasympr
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_tcflongrangeasympr_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_tcflongrangeasympr
    end function rism3d_get_tcflongrangeasympr

    function rism3d_get_dcflongrangeasympr_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_dcflongrangeasympr_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_dcflongrangeasympr_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_dcflongrangeasympr_0
    end function rism3d_get_dcflongrangeasympr_0

    function rism3d_get_dcflongrangeasympr_1(obj, indx) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: indx
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_dcflongrangeasympr_1
        SHT_rv = c_rism3d_get_dcflongrangeasympr_1(obj%cxxmem, indx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_dcflongrangeasympr_1
    end function rism3d_get_dcflongrangeasympr_1

    function rism3d_get_uuv(obj, indx) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, c_f_pointer
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: indx
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_uuv
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_get_uuv_bufferify(obj%cxxmem, indx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_uuv
    end function rism3d_get_uuv

    function rism3d_get_periodic(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(rism3d) :: obj
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_periodic
        SHT_rv = c_rism3d_get_periodic(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_periodic
    end function rism3d_get_periodic

    function rism3d_get_failure(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(rism3d) :: obj
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.get_failure
        SHT_rv = c_rism3d_get_failure(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.get_failure
    end function rism3d_get_failure

    subroutine rism3d_set_atomname(obj, names)
        use iso_c_binding, only : C_INT, C_SIZE_T
        class(rism3d) :: obj
        character(len=*), intent(IN) :: names(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.set_atomname
        call c_rism3d_set_atomname_bufferify(obj%cxxmem, names, &
            size(names, kind=C_SIZE_T), len(names, kind=C_INT))
        ! splicer end namespace.rism3d_c.class.rism3d.method.set_atomname
    end subroutine rism3d_set_atomname

    subroutine rism3d_setverbosity(obj, verbosity)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: verbosity
        ! splicer begin namespace.rism3d_c.class.rism3d.method.setverbosity
        call c_rism3d_setverbosity(obj%cxxmem, verbosity)
        ! splicer end namespace.rism3d_c.class.rism3d.method.setverbosity
    end subroutine rism3d_setverbosity

    subroutine rism3d_settimerparent(obj, timer)
        class(rism3d) :: obj
        type(timer_cpp), intent(INOUT) :: timer
        ! splicer begin namespace.rism3d_c.class.rism3d.method.settimerparent
        call c_rism3d_settimerparent(obj%cxxmem, timer)
        ! splicer end namespace.rism3d_c.class.rism3d.method.settimerparent
    end subroutine rism3d_settimerparent

    subroutine rism3d_setcoord(obj, solutePositions)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE), intent(IN) :: solutePositions(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.setcoord
        call c_rism3d_setcoord(obj%cxxmem, solutePositions)
        ! splicer end namespace.rism3d_c.class.rism3d.method.setcoord
    end subroutine rism3d_setcoord

    function rism3d_calculatesolution(obj, ksave, kshow, maxSteps, &
            failure, tolerance, tol_size) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: ksave
        integer(C_INT), value, intent(IN) :: kshow
        integer(C_INT), value, intent(IN) :: maxSteps
        logical, value, intent(IN) :: failure
        real(C_DOUBLE), intent(INOUT) :: tolerance(:)
        integer(C_INT), value, intent(IN) :: tol_size
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.calculatesolution
        logical(C_BOOL) :: SHT_failure_cxx
        SHT_failure_cxx = failure  ! coerce to C_BOOL
        SHT_rv = c_rism3d_calculatesolution(obj%cxxmem, ksave, kshow, &
            maxSteps, SHT_failure_cxx, tolerance, tol_size)
        ! splicer end namespace.rism3d_c.class.rism3d.method.calculatesolution
    end function rism3d_calculatesolution

    subroutine rism3d_force(obj, ff)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: ff(:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.force
        call c_rism3d_force(obj%cxxmem, ff)
        ! splicer end namespace.rism3d_c.class.rism3d.method.force
    end subroutine rism3d_force

    function rism3d_excesschemicalpotential_tot_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_tot_0
        SHT_rv = c_rism3d_excesschemicalpotential_tot_0(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_tot_0
    end function rism3d_excesschemicalpotential_tot_0

    function rism3d_excesschemicalpotential_tot_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_tot_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        SHT_rv = c_rism3d_excesschemicalpotential_tot_1(obj%cxxmem, &
            SHT_o_lr_cxx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_tot_1
    end function rism3d_excesschemicalpotential_tot_1

    function rism3d_excesschemicalpotential_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotential_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_0
    end function rism3d_excesschemicalpotential_0

    function rism3d_excesschemicalpotential_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_excesschemicalpotential_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_1
    end function rism3d_excesschemicalpotential_1

    function rism3d_excesschemicalpotentialgf_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotentialgf_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_0
    end function rism3d_excesschemicalpotentialgf_0

    function rism3d_excesschemicalpotentialgf_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_excesschemicalpotentialgf_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_1
    end function rism3d_excesschemicalpotentialgf_1

    function rism3d_excesschemicalpotentialpcplus_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialpcplus_0
        SHT_rv = c_rism3d_excesschemicalpotentialpcplus_0(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialpcplus_0
    end function rism3d_excesschemicalpotentialpcplus_0

    function rism3d_excesschemicalpotentialpcplus_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialpcplus_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        SHT_rv = c_rism3d_excesschemicalpotentialpcplus_1(obj%cxxmem, &
            SHT_o_lr_cxx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialpcplus_1
    end function rism3d_excesschemicalpotentialpcplus_1

    function rism3d_excesschemicalpotentialuc_0(obj, coeff) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: coeff(:)
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialuc_0
        SHT_rv = c_rism3d_excesschemicalpotentialuc_0(obj%cxxmem, coeff)
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialuc_0
    end function rism3d_excesschemicalpotentialuc_0

    function rism3d_excesschemicalpotentialuc_1(obj, coeff, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: coeff(:)
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialuc_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        SHT_rv = c_rism3d_excesschemicalpotentialuc_1(obj%cxxmem, coeff, &
            SHT_o_lr_cxx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialuc_1
    end function rism3d_excesschemicalpotentialuc_1

    function rism3d_excesschemicalpotential_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotential_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_tot_map
    end function rism3d_excesschemicalpotential_tot_map

    function rism3d_excesschemicalpotentialgf_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotentialgf_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_tot_map
    end function rism3d_excesschemicalpotentialgf_tot_map

    function rism3d_excesschemicalpotentialpcplus_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialpcplus_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotentialpcplus_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialpcplus_tot_map
    end function rism3d_excesschemicalpotentialpcplus_tot_map

    function rism3d_excesschemicalpotentialuc_tot_map(obj, coeff) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), intent(IN) :: coeff(:)
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialuc_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotentialuc_tot_map_bufferify(obj%cxxmem, &
            coeff, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialuc_tot_map
    end function rism3d_excesschemicalpotentialuc_tot_map

    function rism3d_solventpotene_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solventpotene_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solventpotene_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solventpotene_tot_map
    end function rism3d_solventpotene_tot_map

    function rism3d_solvationenergy_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergy_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergy_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergy_tot_map
    end function rism3d_solvationenergy_tot_map

    function rism3d_solvationenergygf_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergygf_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergygf_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergygf_tot_map
    end function rism3d_solvationenergygf_tot_map

    function rism3d_solvationenergypcplus_tot_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergypcplus_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergypcplus_tot_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergypcplus_tot_map
    end function rism3d_solvationenergypcplus_tot_map

    function rism3d_solvationenergyuc_tot_map(obj, coeff) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), intent(IN) :: coeff(:)
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergyuc_tot_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergyuc_tot_map_bufferify(obj%cxxmem, &
            coeff, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:3))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergyuc_tot_map
    end function rism3d_solvationenergyuc_tot_map

    function rism3d_excesschemicalpotential_site_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_site_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotential_site_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotential_site_map
    end function rism3d_excesschemicalpotential_site_map

    function rism3d_excesschemicalpotentialgf_site_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_site_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excesschemicalpotentialgf_site_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excesschemicalpotentialgf_site_map
    end function rism3d_excesschemicalpotentialgf_site_map

    function rism3d_solventpotene_site_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solventpotene_site_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solventpotene_site_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solventpotene_site_map
    end function rism3d_solventpotene_site_map

    function rism3d_solvationenergy_site_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergy_site_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergy_site_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergy_site_map
    end function rism3d_solvationenergy_site_map

    function rism3d_solventpotene(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solventpotene
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solventpotene_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solventpotene
    end function rism3d_solventpotene

    function rism3d_partialmolarvolume(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.partialmolarvolume
        SHT_rv = c_rism3d_partialmolarvolume(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.partialmolarvolume
    end function rism3d_partialmolarvolume

    function rism3d_excessparticles_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excessparticles_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excessparticles_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excessparticles_0
    end function rism3d_excessparticles_0

    function rism3d_excessparticles_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excessparticles_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_excessparticles_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excessparticles_1
    end function rism3d_excessparticles_1

    function rism3d_kirkwoodbuff_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_kirkwoodbuff_0_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_0
    end function rism3d_kirkwoodbuff_0

    function rism3d_kirkwoodbuff_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_kirkwoodbuff_1_bufferify(obj%cxxmem, SHT_o_lr_cxx, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_1
    end function rism3d_kirkwoodbuff_1

    function rism3d_dcfintegral(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.dcfintegral
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_dcfintegral_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.dcfintegral
    end function rism3d_dcfintegral

    function rism3d_cancalc_dt(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL
        class(rism3d) :: obj
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.cancalc_dt
        SHT_rv = c_rism3d_cancalc_dt(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.cancalc_dt
    end function rism3d_cancalc_dt

    function rism3d_calculatesolution_dt(obj, kshow, maxSteps, failure, &
            tolerance) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: kshow
        integer(C_INT), value, intent(IN) :: maxSteps
        logical, value, intent(IN) :: failure
        real(C_DOUBLE), value, intent(IN) :: tolerance
        logical :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.calculatesolution_dt
        logical(C_BOOL) :: SHT_failure_cxx
        SHT_failure_cxx = failure  ! coerce to C_BOOL
        SHT_rv = c_rism3d_calculatesolution_dt(obj%cxxmem, kshow, &
            maxSteps, SHT_failure_cxx, tolerance)
        ! splicer end namespace.rism3d_c.class.rism3d.method.calculatesolution_dt
    end function rism3d_calculatesolution_dt

    function rism3d_solvationenergy_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergy_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergy_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergy_0
    end function rism3d_solvationenergy_0

    function rism3d_solvationenergy_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergy_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_solvationenergy_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergy_1
    end function rism3d_solvationenergy_1

    function rism3d_solvationenergygf_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergygf_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergygf_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergygf_0
    end function rism3d_solvationenergygf_0

    function rism3d_solvationenergygf_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergygf_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_solvationenergygf_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergygf_1
    end function rism3d_solvationenergygf_1

    function rism3d_solvationenergygf_site_map(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:,:,:,:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergygf_site_map
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_solvationenergygf_site_map_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:4))
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergygf_site_map
    end function rism3d_solvationenergygf_site_map

    function rism3d_excessparticles_dt_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excessparticles_dt_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_excessparticles_dt_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excessparticles_dt_0
    end function rism3d_excessparticles_dt_0

    function rism3d_excessparticles_dt_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.excessparticles_dt_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_excessparticles_dt_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.excessparticles_dt_1
    end function rism3d_excessparticles_dt_1

    function rism3d_kirkwoodbuff_dt_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_dt_0
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_kirkwoodbuff_dt_0_bufferify(obj%cxxmem, &
            SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_dt_0
    end function rism3d_kirkwoodbuff_dt_0

    function rism3d_kirkwoodbuff_dt_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_dt_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        call c_rism3d_kirkwoodbuff_dt_1_bufferify(obj%cxxmem, &
            SHT_o_lr_cxx, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.kirkwoodbuff_dt_1
    end function rism3d_kirkwoodbuff_dt_1

    function rism3d_dcfintegral_dt(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, c_f_pointer
        class(rism3d) :: obj
        real(C_DOUBLE), pointer :: SHT_rv(:)
        ! splicer begin namespace.rism3d_c.class.rism3d.method.dcfintegral_dt
        type(RIS_SHROUD_array) :: SHT_rv_cdesc
        call c_rism3d_dcfintegral_dt_bufferify(obj%cxxmem, SHT_rv_cdesc)
        call c_f_pointer(SHT_rv_cdesc%base_addr, SHT_rv, &
            SHT_rv_cdesc%shape(1:1))
        ! splicer end namespace.rism3d_c.class.rism3d.method.dcfintegral_dt
    end function rism3d_dcfintegral_dt

    function rism3d_solvationenergypcplus_0(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergypcplus_0
        SHT_rv = c_rism3d_solvationenergypcplus_0(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergypcplus_0
    end function rism3d_solvationenergypcplus_0

    function rism3d_solvationenergypcplus_1(obj, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        class(rism3d) :: obj
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergypcplus_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        SHT_rv = c_rism3d_solvationenergypcplus_1(obj%cxxmem, &
            SHT_o_lr_cxx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergypcplus_1
    end function rism3d_solvationenergypcplus_1

    function rism3d_solvationenergyuc_0(obj, coeff) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: coeff(:)
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergyuc_0
        SHT_rv = c_rism3d_solvationenergyuc_0(obj%cxxmem, coeff)
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergyuc_0
    end function rism3d_solvationenergyuc_0

    function rism3d_solvationenergyuc_1(obj, coeff, o_lr) &
            result(SHT_rv)
        use iso_c_binding, only : C_BOOL, C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: coeff(:)
        logical, value, intent(IN) :: o_lr
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.solvationenergyuc_1
        logical(C_BOOL) :: SHT_o_lr_cxx
        SHT_o_lr_cxx = o_lr  ! coerce to C_BOOL
        SHT_rv = c_rism3d_solvationenergyuc_1(obj%cxxmem, coeff, &
            SHT_o_lr_cxx)
        ! splicer end namespace.rism3d_c.class.rism3d.method.solvationenergyuc_1
    end function rism3d_solvationenergyuc_1

    function rism3d_partialmolarvolume_dt(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE
        class(rism3d) :: obj
        real(C_DOUBLE) :: SHT_rv
        ! splicer begin namespace.rism3d_c.class.rism3d.method.partialmolarvolume_dt
        SHT_rv = c_rism3d_partialmolarvolume_dt(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.partialmolarvolume_dt
    end function rism3d_partialmolarvolume_dt

    subroutine rism3d_unsetcharges(obj)
        class(rism3d) :: obj
        ! splicer begin namespace.rism3d_c.class.rism3d.method.unsetcharges
        call c_rism3d_unsetcharges(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.unsetcharges
    end subroutine rism3d_unsetcharges

    subroutine rism3d_resetcharges(obj)
        class(rism3d) :: obj
        ! splicer begin namespace.rism3d_c.class.rism3d.method.resetcharges
        call c_rism3d_resetcharges(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.resetcharges
    end subroutine rism3d_resetcharges

    subroutine rism3d_map_site_to_site_flat(obj, thermo_map_flat, &
            center_site)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: thermo_map_flat(:,:)
        integer(C_INT), value, intent(IN) :: center_site
        ! splicer begin namespace.rism3d_c.class.rism3d.method.map_site_to_site_flat
        call c_rism3d_map_site_to_site_flat(obj%cxxmem, thermo_map_flat, &
            center_site)
        ! splicer end namespace.rism3d_c.class.rism3d.method.map_site_to_site_flat
    end subroutine rism3d_map_site_to_site_flat

    subroutine rism3d_map_site_to_site_3_d(obj, thermo_map, center_site)
        use iso_c_binding, only : C_DOUBLE, C_INT
        class(rism3d) :: obj
        real(C_DOUBLE), intent(INOUT) :: thermo_map(:,:,:,:)
        integer(C_INT), value, intent(IN) :: center_site
        ! splicer begin namespace.rism3d_c.class.rism3d.method.map_site_to_site_3_d
        call c_rism3d_map_site_to_site_3_d(obj%cxxmem, thermo_map, &
            center_site)
        ! splicer end namespace.rism3d_c.class.rism3d.method.map_site_to_site_3_d
    end subroutine rism3d_map_site_to_site_3_d

    subroutine rism3d_selftest(obj)
        class(rism3d) :: obj
        ! splicer begin namespace.rism3d_c.class.rism3d.method.selftest
        call c_rism3d_selftest(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.selftest
    end subroutine rism3d_selftest

    subroutine rism3d_set_closurelist(obj, names, N)
        use iso_c_binding, only : C_INT, C_SIZE_T
        class(rism3d) :: obj
        character(len=*), intent(IN) :: names(:)
        integer(C_INT), intent(IN) :: N
        ! splicer begin namespace.rism3d_c.class.rism3d.method.set_closurelist
        call c_rism3d_set_closurelist_bufferify(obj%cxxmem, names, &
            size(names, kind=C_SIZE_T), len(names, kind=C_INT), N)
        ! splicer end namespace.rism3d_c.class.rism3d.method.set_closurelist
    end subroutine rism3d_set_closurelist

    subroutine rism3d_print_tests(obj)
        class(rism3d) :: obj
        ! splicer begin namespace.rism3d_c.class.rism3d.method.print_tests
        call c_rism3d_print_tests(obj%cxxmem)
        ! splicer end namespace.rism3d_c.class.rism3d.method.print_tests
    end subroutine rism3d_print_tests

    subroutine rism3d_opendx_write_cpp(obj, atomType, file)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: atomType
        character(len=*), intent(IN) :: file
        ! splicer begin namespace.rism3d_c.class.rism3d.method.opendx_write_cpp
        integer(C_INT) SHT_file_len
        SHT_file_len = len(file, kind=C_INT)
        call c_rism3d_opendx_write_cpp_bufferify(obj%cxxmem, atomType, &
            file, SHT_file_len)
        ! splicer end namespace.rism3d_c.class.rism3d.method.opendx_write_cpp
    end subroutine rism3d_opendx_write_cpp

    subroutine rism3d_mrc_map_write_cpp(obj, atomType, file)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: atomType
        character(len=*), intent(IN) :: file
        ! splicer begin namespace.rism3d_c.class.rism3d.method.mrc_map_write_cpp
        integer(C_INT) SHT_file_len
        SHT_file_len = len(file, kind=C_INT)
        call c_rism3d_mrc_map_write_cpp_bufferify(obj%cxxmem, atomType, &
            file, SHT_file_len)
        ! splicer end namespace.rism3d_c.class.rism3d.method.mrc_map_write_cpp
    end subroutine rism3d_mrc_map_write_cpp

    subroutine rism3d_xyzv_write_cpp(obj, atomType, file)
        use iso_c_binding, only : C_INT
        class(rism3d) :: obj
        integer(C_INT), value, intent(IN) :: atomType
        character(len=*), intent(IN) :: file
        ! splicer begin namespace.rism3d_c.class.rism3d.method.xyzv_write_cpp
        integer(C_INT) SHT_file_len
        SHT_file_len = len(file, kind=C_INT)
        call c_rism3d_xyzv_write_cpp_bufferify(obj%cxxmem, atomType, &
            file, SHT_file_len)
        ! splicer end namespace.rism3d_c.class.rism3d.method.xyzv_write_cpp
    end subroutine rism3d_xyzv_write_cpp

    ! Return pointer to C++ memory.
    function rism3d_get_instance(obj) result (cxxptr)
        use iso_c_binding, only: C_PTR
        class(rism3d), intent(IN) :: obj
        type(C_PTR) :: cxxptr
        cxxptr = obj%cxxmem%addr
    end function rism3d_get_instance

    subroutine rism3d_set_instance(obj, cxxmem)
        use iso_c_binding, only: C_PTR
        class(rism3d), intent(INOUT) :: obj
        type(C_PTR), intent(IN) :: cxxmem
        obj%cxxmem%addr = cxxmem
        obj%cxxmem%idtor = 0
    end subroutine rism3d_set_instance

    function rism3d_associated(obj) result (rv)
        use iso_c_binding, only: c_associated
        class(rism3d), intent(IN) :: obj
        logical rv
        rv = c_associated(obj%cxxmem%addr)
    end function rism3d_associated

    ! splicer begin namespace.rism3d_c.class.rism3d.additional_functions
    pure function rism3d_get_numatoms(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(rism3d), intent(in) :: obj
        integer(C_INT) :: SHT_rv
        SHT_rv = c_rism3d_get_numatoms(obj%cxxmem)
    end function rism3d_get_numatoms

    pure function rism3d_get_numatomtypes(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(rism3d), intent(in) :: obj
        integer(C_INT) :: SHT_rv
        SHT_rv = c_rism3d_get_numatomtypes(obj%cxxmem)
    end function rism3d_get_numatomtypes

    ! splicer end namespace.rism3d_c.class.rism3d.additional_functions

    ! splicer begin namespace.rism3d_c.additional_functions
    subroutine cpy_solute(this, solute)
        type(solute_cpp) :: this
        type(rism3d_solute) :: solute
        REAL, target :: COM(3)
        REAL, target :: trans(3)

        COM = solute%centerOfMass
        trans = solute%translation

        this%numAtoms = solute%numAtoms
        this%charged = solute%charged
        this%mass = C_LOC(solute%mass)
        this%charge = C_LOC(solute%charge)
        this%ljSigma = C_LOC(solute%ljSigma)
        this%ljEpsilon = C_LOC(solute%ljEpsilon)
        this%centerOfMass = C_LOC(COM)
        this%translation = C_LOC(trans)
        this%origCharge = C_LOC(solute%origCharge)
        this%position = C_LOC(solute%position)
        this%totalCharge = solute%totalCharge
    end subroutine cpy_solute

    subroutine cpy_solvent(this, solvent)
        type(solvent_cpp) :: this
        type(rism3d_solvent) :: solvent

        this%temperature = solvent%temperature
        this%dielconst = solvent%dielconst
        this%xappa = solvent%xappa
        this%xikt = solvent%xikt
        this%smear = solvent%smear
        this%xikt_dT = solvent%xikt_dT
        this%numAtomTypes = solvent%numAtomTypes
        this%numMolecules = solvent%numMolecules
        this%numRDFpoints = solvent%numRDFpoints
        this%atomMultiplicity = C_LOC(solvent%atomMultiplicity)
        this%numAtoms = C_LOC(solvent%numAtoms)
        this%gridSpacingR = solvent%gridSpacingR
        this%gridSpacingK = solvent%gridSpacingK
        this%waveNumbers = C_LOC(solvent%waveNumbers)
        this%xvv = C_LOC(solvent%xvv)
        this%xvv_dT = C_LOC(solvent%xvv_dT)
        this%charge = C_LOC(solvent%charge)
        this%charge_sp = C_LOC(solvent%charge_sp)
        this%density = C_LOC(solvent%density)
        this%density_sp = C_LOC(solvent%density_sp)
        this%ljSigma = C_LOC(solvent%ljSigma)
        this%ljEpsilon = C_LOC(solvent%ljEpsilon)
        this%coord = C_LOC(solvent%coord)
        this%background_correction = C_LOC(solvent%background_correction)
        this%delhv0 = C_LOC(solvent%delhv0)
        this%delhv0_dT = C_LOC(solvent%delhv0_dT)
        this%ionic = solvent%ionic
        this%xvv_version = solvent%xvv_version
    end subroutine cpy_solvent
    ! splicer end namespace.rism3d_c.additional_functions

    function rism3d_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(rism3d), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function rism3d_eq

    function rism3d_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(rism3d), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function rism3d_ne

end module rism3d_rism3d_c_mod
